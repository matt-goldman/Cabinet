using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Cabinet.SourceGenerators;

[Generator]
public class AotRecordGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all classes and records with [AotRecord] attribute
		var types = context.SyntaxProvider
			.ForAttributeWithMetadataName(
				"Cabinet.AotRecordAttribute",
				predicate: static (node, _) => node is TypeDeclarationSyntax or RecordDeclarationSyntax,
				transform: static (context, _) => GetClassInfo(context))
			.Where(static m => m is not null);

		// Collect all classes and generate code
		var compilationAndClasses = context.CompilationProvider.Combine(types.Collect());

		context.RegisterSourceOutput(compilationAndClasses,
			static (spc, source) => Execute(source.Left, source.Right!, spc));
	}

	private static ClassInfo? GetClassInfo(GeneratorAttributeSyntaxContext context)
	{
		if (context.TargetNode is not TypeDeclarationSyntax and not RecordDeclarationSyntax)
			return null;

		var symbol = context.TargetSymbol as INamedTypeSymbol;
		if (symbol is null)
			return null;

		// Get the attribute data
		var attributeData = context.Attributes.FirstOrDefault();
		if (attributeData is null)
			return null;

		// Extract IdPropertyName and FileName from attribute if specified
		string? explicitIdPropertyName = null;
		string? fileName = null;

		foreach (var namedArg in attributeData.NamedArguments)
		{
			if (namedArg.Key == "IdPropertyName" && namedArg.Value.Value is string idProp)
				explicitIdPropertyName = idProp;
			else if (namedArg.Key == "FileName" && namedArg.Value.Value is string file)
				fileName = file;
		}

		// Find ID property
		var idProperty = FindIdProperty(symbol, explicitIdPropertyName);
		if (idProperty is null)
			return null;

		// Store whether the class is public for informational purposes; no validation occurs
		var isPublic = symbol.DeclaredAccessibility == Accessibility.Public;

		// Determine accessibility modifier
		var accessibility = symbol.DeclaredAccessibility switch
		{
			Accessibility.Public => "public",
			Accessibility.Internal => "internal",
			Accessibility.Private => "private",
			Accessibility.Protected => "protected",
			Accessibility.ProtectedOrInternal => "protected internal",
			Accessibility.ProtectedAndInternal => "private protected",
			_ => "internal" // Default to internal for safety
		};

		return new ClassInfo(
			symbol.Name,
			symbol.ContainingNamespace.ToDisplayString(),
			idProperty.Name,
			fileName ?? symbol.Name,
			accessibility,
			isPublic,
			symbol.Locations.FirstOrDefault());
	}

	private static IPropertySymbol? FindIdProperty(INamedTypeSymbol classSymbol, string? explicitName)
	{
		// If explicit name is specified, use it
		if (explicitName is not null && explicitName.Length > 0)
		{
			return classSymbol.GetMembers(explicitName)
				.OfType<IPropertySymbol>()
				.FirstOrDefault();
		}

		// Try "Id" first
		var idProperty = classSymbol.GetMembers("Id")
			.OfType<IPropertySymbol>()
			.FirstOrDefault();

		if (idProperty is not null)
			return idProperty;

		// Try "{TypeName}Id"
		var typeNameId = $"{classSymbol.Name}Id";
		return classSymbol.GetMembers(typeNameId)
			.OfType<IPropertySymbol>()
			.FirstOrDefault();
	}

	private static void Execute(Compilation compilation, ImmutableArray<ClassInfo?> classes, SourceProductionContext context)
	{
		if (classes.IsDefaultOrEmpty)
			return;

		var allClasses = classes.Where(c => c is not null).Cast<ClassInfo>().ToList();
		if (allClasses.Count == 0)
			return;

		// Generate RecordSet extensions for each class
		foreach (var classInfo in allClasses)
		{
			var extensionSource = GenerateRecordSetExtensions(classInfo);
			context.AddSource($"{classInfo.ClassName}Extensions.g.cs", SourceText.From(extensionSource, Encoding.UTF8));
		}

		// Generate store helper extensions
		var storeExtensionsSource = GenerateStoreExtensions(allClasses);
		context.AddSource("CabinetStoreExtensions.g.cs", SourceText.From(storeExtensionsSource, Encoding.UTF8));
	}

	private static string GenerateRecordSetExtensions(ClassInfo classInfo)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using Cabinet;");
		sb.AppendLine("using Cabinet.Abstractions;");
		sb.AppendLine("using Cabinet.Core;");
		sb.AppendLine($"using {classInfo.Namespace};");
		sb.AppendLine();
		sb.AppendLine("namespace Cabinet.Generated;");
		sb.AppendLine();
		sb.AppendLine($"{classInfo.Accessibility} static class {classInfo.ClassName}Extensions");
		sb.AppendLine("{");
		sb.AppendLine($"\t{classInfo.Accessibility} static RecordSetOptions<{classInfo.ClassName}> CreateRecordSetOptions()");
		sb.AppendLine("\t\t=> new()");
		sb.AppendLine("\t\t{");
		// Convert Id property to string using ToString() to handle both string and non-string types
		sb.AppendLine($"\t\t\tIdSelector = record => record.{classInfo.IdPropertyName}.ToString()!");
		sb.AppendLine("\t\t};");
		sb.AppendLine();
		sb.AppendLine($"\t{classInfo.Accessibility} static RecordSet<{classInfo.ClassName}> CreateRecordSet(this IOfflineStore store)");
		sb.AppendLine($"\t\t=> new(store, CreateRecordSetOptions());");
		sb.AppendLine("}");

		return sb.ToString();
	}

	private static string GenerateStoreExtensions(List<ClassInfo> classes)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System.Text.Json;");
		sb.AppendLine("using System.Text.Json.Serialization;");
		sb.AppendLine("using Cabinet;");
		sb.AppendLine("using Cabinet.Abstractions;");
		sb.AppendLine("using Cabinet.Core;");
		sb.AppendLine("using Cabinet.Index;");
		sb.AppendLine("using Cabinet.Security;");
		sb.AppendLine();

		// Add using statements for each namespace
		var namespaces = classes.Select(c => c.Namespace).Distinct().OrderBy(n => n);
		foreach (var ns in namespaces)
		{
			sb.AppendLine($"using {ns};");
		}

		sb.AppendLine();
		sb.AppendLine("namespace Cabinet.Generated;");
		sb.AppendLine();

		// Determine the most restrictive accessibility from all classes
		// If any class is internal, the whole extension class must be internal
		var hasInternal = classes.Any(c => c.Accessibility == "internal");
		var extensionAccessibility = hasInternal ? "internal" : "public";

		sb.AppendLine($"{extensionAccessibility} static class CabinetStoreExtensions");
		sb.AppendLine("{");

		// CreateCabinetStore method - uses the same accessibility as the extension class
		sb.AppendLine($"\t{extensionAccessibility} static IOfflineStore CreateCabinetStore(");
		sb.AppendLine("\t\tstring dataDirectory,");
		sb.AppendLine("\t\tbyte[] masterKey,");
		sb.AppendLine("\t\tJsonSerializerContext jsonContext)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tvar encryptionProvider = new AesGcmEncryptionProvider(masterKey);");
		sb.AppendLine("\t\tvar indexProvider = new PersistentIndexProvider(dataDirectory, encryptionProvider);");
		sb.AppendLine("\t\treturn new FileOfflineStore(");
		sb.AppendLine("\t\t\tdataDirectory,");
		sb.AppendLine("\t\t\tencryptionProvider,");
		sb.AppendLine("\t\t\tjsonContext.Options,");
		sb.AppendLine("\t\t\tindexProvider);");
		sb.AppendLine("\t}");

		// Generate named RecordSet creation methods for each type
		foreach (var classInfo in classes)
		{
			sb.AppendLine();
			sb.AppendLine($"\t{classInfo.Accessibility} static RecordSet<{classInfo.ClassName}> Create{classInfo.ClassName}RecordSet(this IOfflineStore store)");
			sb.AppendLine($"\t\t=> new(store, {classInfo.ClassName}Extensions.CreateRecordSetOptions());");
		}

		sb.AppendLine("}");

		return sb.ToString();
	}

	private record ClassInfo(
		string ClassName,
		string Namespace,
		string IdPropertyName,
		string FileName,
		string Accessibility,
		bool IsPublic,
		Location? Location);
}
