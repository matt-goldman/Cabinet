using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Cabinet.SourceGenerators;

[Generator]
public class AotRecordGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all classes with [AotRecord] attribute
		var classDeclarations = context.SyntaxProvider
			.ForAttributeWithMetadataName(
				"Cabinet.AotRecordAttribute",
				predicate: static (node, _) => node is ClassDeclarationSyntax,
				transform: static (context, _) => GetClassInfo(context))
			.Where(static m => m is not null);

		// Collect all classes and generate code
		var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

		context.RegisterSourceOutput(compilationAndClasses,
			static (spc, source) => Execute(source.Left, source.Right!, spc));
	}

	private static ClassInfo? GetClassInfo(GeneratorAttributeSyntaxContext context)
	{
		if (context.TargetNode is not ClassDeclarationSyntax classDeclaration)
			return null;

		var symbol = context.TargetSymbol as INamedTypeSymbol;
		if (symbol is null)
			return null;

		// Get the attribute data
		var attributeData = context.Attributes.FirstOrDefault();
		if (attributeData is null)
			return null;

		// Extract IdPropertyName and FileName from attribute if specified
		string? explicitIdPropertyName = null;
		string? fileName = null;

		foreach (var namedArg in attributeData.NamedArguments)
		{
			if (namedArg.Key == "IdPropertyName" && namedArg.Value.Value is string idProp)
				explicitIdPropertyName = idProp;
			else if (namedArg.Key == "FileName" && namedArg.Value.Value is string file)
				fileName = file;
		}

		// Find ID property
		var idProperty = FindIdProperty(symbol, explicitIdPropertyName);
		if (idProperty is null)
			return null;

		return new ClassInfo(
			symbol.Name,
			symbol.ContainingNamespace.ToDisplayString(),
			idProperty.Name,
			fileName ?? symbol.Name);
	}

	private static IPropertySymbol? FindIdProperty(INamedTypeSymbol classSymbol, string? explicitName)
	{
		// If explicit name is specified, use it
		if (!string.IsNullOrEmpty(explicitName))
		{
			return classSymbol.GetMembers(explicitName!)
				.OfType<IPropertySymbol>()
				.FirstOrDefault();
		}

		// Try "Id" first
		var idProperty = classSymbol.GetMembers("Id")
			.OfType<IPropertySymbol>()
			.FirstOrDefault();

		if (idProperty is not null)
			return idProperty;

		// Try "{TypeName}Id"
		var typeNameId = $"{classSymbol.Name}Id";
		return classSymbol.GetMembers(typeNameId)
			.OfType<IPropertySymbol>()
			.FirstOrDefault();
	}

	private static void Execute(Compilation compilation, ImmutableArray<ClassInfo?> classes, SourceProductionContext context)
	{
		if (classes.IsDefaultOrEmpty)
			return;

		var validClasses = classes.Where(c => c is not null).Cast<ClassInfo>().ToList();
		if (validClasses.Count == 0)
			return;

		// Generate JSON Serialization Context
		var jsonContextSource = GenerateJsonSerializerContext(validClasses);
		context.AddSource("CabinetJsonSerializerContext.g.cs", SourceText.From(jsonContextSource, Encoding.UTF8));

		// Generate RecordSet extensions for each class
		foreach (var classInfo in validClasses)
		{
			var extensionSource = GenerateRecordSetExtensions(classInfo);
			context.AddSource($"{classInfo.ClassName}Extensions.g.cs", SourceText.From(extensionSource, Encoding.UTF8));
		}

		// Generate store helper extensions
		var storeExtensionsSource = GenerateStoreExtensions(validClasses);
		context.AddSource("CabinetStoreExtensions.g.cs", SourceText.From(storeExtensionsSource, Encoding.UTF8));
	}

	private static string GenerateJsonSerializerContext(List<ClassInfo> classes)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System.Collections.Generic;");
		sb.AppendLine("using System.Text.Json;");
		sb.AppendLine("using System.Text.Json.Serialization;");
		sb.AppendLine();

		// Add using statements for each namespace
		var namespaces = classes.Select(c => c.Namespace).Distinct().OrderBy(n => n);
		foreach (var ns in namespaces)
		{
			sb.AppendLine($"using {ns};");
		}

		sb.AppendLine();
		sb.AppendLine("namespace Cabinet.Generated;");
		sb.AppendLine();

		// Add [JsonSerializable] attributes for each type and List<T>
		foreach (var classInfo in classes)
		{
			sb.AppendLine($"[JsonSerializable(typeof({classInfo.ClassName}))]");
			sb.AppendLine($"[JsonSerializable(typeof(List<{classInfo.ClassName}>))]");
		}

		sb.AppendLine("[JsonSourceGenerationOptions(");
		sb.AppendLine("\tWriteIndented = false,");
		sb.AppendLine("\tPropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,");
		sb.AppendLine("\tDefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]");
		sb.AppendLine("public partial class CabinetJsonSerializerContext : JsonSerializerContext");
		sb.AppendLine("{");
		sb.AppendLine("}");

		return sb.ToString();
	}

	private static string GenerateRecordSetExtensions(ClassInfo classInfo)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using Cabinet;");
		sb.AppendLine("using Cabinet.Core;");
		sb.AppendLine($"using {classInfo.Namespace};");
		sb.AppendLine();
		sb.AppendLine("namespace Cabinet.Generated;");
		sb.AppendLine();
		sb.AppendLine($"public static class {classInfo.ClassName}Extensions");
		sb.AppendLine("{");
		sb.AppendLine($"\tpublic static RecordSetOptions<{classInfo.ClassName}> CreateRecordSetOptions()");
		sb.AppendLine("\t\t=> new()");
		sb.AppendLine("\t\t{");
		sb.AppendLine($"\t\t\tIdSelector = record => record.{classInfo.IdPropertyName}");
		sb.AppendLine("\t\t};");
		sb.AppendLine();
		sb.AppendLine($"\tpublic static RecordSet<{classInfo.ClassName}> CreateRecordSet(this IOfflineStore store)");
		sb.AppendLine($"\t\t=> new(store, CreateRecordSetOptions());");
		sb.AppendLine("}");

		return sb.ToString();
	}

	private static string GenerateStoreExtensions(List<ClassInfo> classes)
	{
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System.Text.Json;");
		sb.AppendLine("using Cabinet;");
		sb.AppendLine("using Cabinet.Core;");
		sb.AppendLine("using Cabinet.Security;");
		sb.AppendLine();
		sb.AppendLine("namespace Cabinet.Generated;");
		sb.AppendLine();
		sb.AppendLine("public static class CabinetStoreExtensions");
		sb.AppendLine("{");
		sb.AppendLine("\tpublic static IOfflineStore CreateCabinetStore(");
		sb.AppendLine("\t\tstring dataDirectory,");
		sb.AppendLine("\t\tbyte[] masterKey)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tvar encryptionProvider = new AesGcmEncryptionProvider(masterKey);");
		sb.AppendLine("\t\treturn new FileOfflineStore(");
		sb.AppendLine("\t\t\tdataDirectory,");
		sb.AppendLine("\t\t\tencryptionProvider,");
		sb.AppendLine("\t\t\tnew JsonSerializerOptions");
		sb.AppendLine("\t\t\t{");
		sb.AppendLine("\t\t\t\tTypeInfoResolver = CabinetJsonSerializerContext.Default");
		sb.AppendLine("\t\t\t});");
		sb.AppendLine("\t}");
		sb.AppendLine("}");

		return sb.ToString();
	}

	private record ClassInfo(
		string ClassName,
		string Namespace,
		string IdPropertyName,
		string FileName);
}
