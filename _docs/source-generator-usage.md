# Source Generator Usage Guide

> **⚠️ CRITICAL REQUIREMENT:** Before using the source generator, you **must** manually create a `JsonSerializerContext` in your project. This is required for AOT compilation and cannot be automated. See [Step 2: Create a JsonSerializerContext](#2-create-a-jsonserializercontext) below.

## Overview

The Cabinet source generator (`AotRecordGenerator`) automatically creates RecordSet extensions and helper methods for records marked with the `[AotRecord]` attribute. This enables AOT-safe, strongly-typed access to your offline data.

## Basic Usage

### 1. Mark Your Record with `[AotRecord]`

```csharp
using Cabinet;

namespace MyApp.Models;

[AotRecord]
public record LessonRecord
{
    public Guid Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
}
```

### 2. Create a JsonSerializerContext

**Important:** You must manually create a `JsonSerializerContext` in your project. Source generators cannot reliably chain with System.Text.Json's generator, so this must be in your own code:

```csharp
using System.Text.Json.Serialization;
using MyApp.Models;

namespace MyApp;

[JsonSerializable(typeof(LessonRecord))]
[JsonSerializable(typeof(List<LessonRecord>))]
[JsonSourceGenerationOptions(
    WriteIndented = false,
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]
public partial class CabinetJsonContext : JsonSerializerContext
{
}
```

### 3. Use the Generated Extensions

The source generator creates several helper methods:

```csharp
using Cabinet.Abstractions;
using Cabinet.Generated;
using MyApp.Models;

// Create the store using the generated extension
var store = CabinetStoreExtensions.CreateCabinetStore(
    dataDirectory: "/path/to/data",
    masterKey: myEncryptionKey,
    jsonContext: CabinetJsonContext.Default);

// Create a RecordSet using the generated extension
var lessons = store.CreateLessonRecordRecordSet();

// Or use the explicit method
var lessons2 = LessonRecordExtensions.CreateRecordSet(store);

// Save and load data
await lessons.SaveAsync(new LessonRecord 
{ 
    Id = Guid.NewGuid(),
    Title = "My Lesson",
    Content = "Lesson content",
    CreatedAt = DateTime.UtcNow
});

var allLessons = await lessons.LoadAllAsync();
```

## Generated Code

For each record marked with `[AotRecord]`, the generator creates:

1. **`{RecordName}Extensions.cs`** - RecordSet creation methods
2. **`CabinetStoreExtensions.cs`** - Convenience method to create the IOfflineStore with all necessary dependencies

### Example Generated Code

#### LessonRecordExtensions.g.cs

```csharp
// <auto-generated/>
#nullable enable

using Cabinet;
using Cabinet.Abstractions;
using Cabinet.Core;
using MyApp.Models;

namespace Cabinet.Generated;

public static class LessonRecordExtensions
{
    public static RecordSetOptions<LessonRecord> CreateRecordSetOptions()
        => new()
        {
            IdSelector = record => record.Id.ToString()!
        };

    public static RecordSet<LessonRecord> CreateRecordSet(this IOfflineStore store)
        => new(store, CreateRecordSetOptions());
}
```

#### CabinetStoreExtensions.g.cs

```csharp
// <auto-generated/>
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;
using Cabinet;
using Cabinet.Abstractions;
using Cabinet.Core;
using Cabinet.Index;
using Cabinet.Security;
using MyApp.Models;

namespace Cabinet.Generated;

public static class CabinetStoreExtensions
{
    public static IOfflineStore CreateCabinetStore(
        string dataDirectory,
        byte[] masterKey,
        JsonSerializerContext jsonContext)
    {
        var encryptionProvider = new AesGcmEncryptionProvider(masterKey);
        var indexProvider = new PersistentIndexProvider(dataDirectory, encryptionProvider);
        return new FileOfflineStore(
            dataDirectory,
            encryptionProvider,
            jsonContext.Options,
            indexProvider);
    }

    public static RecordSet<LessonRecord> CreateLessonRecordRecordSet(this IOfflineStore store)
        => new(store, LessonRecordExtensions.CreateRecordSetOptions());
}
```

## ID Property Detection

The generator looks for an ID property in this order:

1. Property named `Id` (any type)
2. Property named `{TypeName}Id` (e.g., `LessonRecordId` for `LessonRecord`)

The ID property can be any type - the generator automatically calls `.ToString()!` to convert it to the string required by `RecordSetOptions<T>.IdSelector`.

## Accessibility Modifiers

Generated extension classes match the accessibility of your record class:

- `public record` → generates `public static class Extensions`
- `internal record` → generates `internal static class Extensions`
- etc.

## AOT Compatibility

This approach is fully AOT-compatible because:

1. System.Text.Json's source generator processes your manually created `JsonSerializerContext`
2. No reflection is used at runtime
3. All JSON serialisation is resolved at compile time
4. The generated extensions use compile-time type information

## Why Manual JsonSerializerContext?

Source generators run during compilation but cannot reliably coordinate with each other. If our generator tried to create the `JsonSerializerContext`, System.Text.Json's generator wouldn't see it in time to implement the abstract members. By having you create it manually in your own code, System.Text.Json's generator can process it correctly.

## Integration with .NET MAUI

Example MauiProgram.cs configuration:

```csharp
using Microsoft.Extensions.Logging;
using Cabinet;
using Cabinet.Abstractions;
using Cabinet.Generated;
using System.Security.Cryptography;

public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        
        // Configure offline data store
        builder.Services.AddSingleton<IOfflineStore>(sp =>
        {
            // Get or create master key from secure storage
            var keyString = SecureStorage.GetAsync("CabinetMasterKey").GetAwaiter().GetResult();
            byte[] masterKey;
            
            if (keyString == null)
            {
                var newKey = new byte[32];
                RandomNumberGenerator.Fill(newKey);
                keyString = Convert.ToBase64String(newKey);
                SecureStorage.SetAsync("CabinetMasterKey", keyString).GetAwaiter().GetResult();
                masterKey = newKey;
            }
            else
            {
                masterKey = Convert.FromBase64String(keyString);
            }
            
            var rootPath = Path.Combine(FileSystem.AppDataDirectory, "Cabinet");
            
            // Use source-generated store creation
            return CabinetStoreExtensions.CreateCabinetStore(
                rootPath,
                masterKey,
                CabinetJsonContext.Default);
        });
        
        return builder.Build();
    }
}
```

## Troubleshooting

### "CS0534: does not implement inherited abstract member"

This means System.Text.Json's generator didn't process your `JsonSerializerContext`. Make sure:

1. The context is in your own code file (not generated)
2. It has the `partial` keyword
3. It has `[JsonSerializable]` attributes for all your types
4. You've rebuilt the project from scratch

### "Cannot convert Guid to string"

This should be automatically handled by the generator (it adds `.ToString()!`). If you see this error, the generator may not be running. Check:

1. The source generator is referenced in your `.csproj` with `OutputItemType="Analyzer"`
2. You've marked your record with `[AotRecord]`
3. You've rebuilt the project

### Generated code not appearing

Source generator output is only visible during build. To see generated files:

1. Build the project
2. Check `obj/Debug/{target}/generated/Cabinet.SourceGenerators/` folder
3. In Visual Studio, expand Dependencies → Analyzers → Cabinet.SourceGenerators
