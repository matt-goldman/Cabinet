# Source Generator Usage Guide

> **⚠️ CRITICAL REQUIREMENTS:**
>
> 1. You **must** manually create a `JsonSerializerContext` in your project (System.Text.Json requires this for AOT, cannot be automated by source generators)
> 2. **All record types must have the same accessibility** - All `[AotRecord]` classes and your `JsonSerializerContext` must be either all public or all internal (C# language rule: types in public members must be public)
>
> **The source generator only creates convenience methods** (RecordSet extensions, CreateCabinetStore). It does NOT generate JsonSerializerContext - you always create that yourself.

## Overview

The Cabinet source generator (`AotRecordGenerator`) automatically creates RecordSet extensions and helper methods for records marked with the `[AotRecord]` attribute, matching the accessibility of your record classes.

## Basic Usage

### 1. Mark Your Record with `[AotRecord]`

```csharp
using Cabinet;

namespace MyApp.Models;

// Public records - will generate public helper methods
[AotRecord]
public record LessonRecord
{
    public Guid Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
}

// Internal records - will generate internal helper methods
[AotRecord]
internal record InternalNote
{
    public Guid Id { get; set; }
    public string Content { get; set; } = string.Empty;
}
```

**Important:** All `[AotRecord]` classes and your `JsonSerializerContext` must have the same accessibility. If you mix public and internal records, the generated `CabinetStoreExtensions` will be internal (most restrictive), so your `JsonSerializerContext` must also be internal.

### 2. Create a JsonSerializerContext

**Important:** You must manually create a `JsonSerializerContext` with the **same accessibility** as your records. Source generators cannot reliably chain with System.Text.Json's generator, so this must be in your own code.

**Example with public records:**

```csharp
using System.Text.Json.Serialization;
using MyApp.Models;

namespace MyApp;

[JsonSerializable(typeof(LessonRecord))]
[JsonSerializable(typeof(List<LessonRecord>))]
[JsonSourceGenerationOptions(
    WriteIndented = false,
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]
public partial class CabinetJsonContext : JsonSerializerContext
{
}
```

**Example with internal records:**

```csharp
using System.Text.Json.Serialization;
using MyApp.Models;

namespace MyApp;

[JsonSerializable(typeof(InternalNote))]
[JsonSerializable(typeof(List<InternalNote>))]
internal partial class CabinetJsonContext : JsonSerializerContext
{
}
```

**Mixed public and internal records:**

If you use both public and internal records, your context **must be internal** (C# rule: internal types can't appear in public members):

```csharp
[JsonSerializable(typeof(LessonRecord))]    // public record
[JsonSerializable(typeof(InternalNote))]   // internal record
internal partial class CabinetJsonContext : JsonSerializerContext  // must be internal
{
}
```

### 3. Use the Generated Extensions

The source generator creates several helper methods:

```csharp
using Cabinet.Abstractions;
using Cabinet.Generated;
using MyApp.Models;

// Create the store using the generated extension
var store = CabinetStoreExtensions.CreateCabinetStore(
    dataDirectory: "/path/to/data",
    masterKey: myEncryptionKey,
    jsonContext: CabinetJsonContext.Default);

// Create a RecordSet using the generated extension
var lessons = store.CreateLessonRecordRecordSet();

// Or use the explicit method
var lessons2 = LessonRecordExtensions.CreateRecordSet(store);

// Save and load data
await lessons.SaveAsync(new LessonRecord 
{ 
    Id = Guid.NewGuid(),
    Title = "My Lesson",
    Content = "Lesson content",
    CreatedAt = DateTime.UtcNow
});

var allLessons = await lessons.LoadAllAsync();
```

## Generated Code

For each record marked with `[AotRecord]`, the generator creates:

1. **`{RecordName}Extensions.cs`** - RecordSet creation methods
2. **`CabinetStoreExtensions.cs`** - Convenience method to create the IOfflineStore with all necessary dependencies

### Example Generated Code

#### LessonRecordExtensions.g.cs

```csharp
// <auto-generated/>
#nullable enable

using Cabinet;
using Cabinet.Abstractions;
using Cabinet.Core;
using MyApp.Models;

namespace Cabinet.Generated;

public static class LessonRecordExtensions
{
    public static RecordSetOptions<LessonRecord> CreateRecordSetOptions()
        => new()
        {
            IdSelector = record => record.Id.ToString()!
        };

    public static RecordSet<LessonRecord> CreateRecordSet(this IOfflineStore store)
        => new(store, CreateRecordSetOptions());
}
```

#### CabinetStoreExtensions.g.cs

```csharp
// <auto-generated/>
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;
using Cabinet;
using Cabinet.Abstractions;
using Cabinet.Core;
using Cabinet.Index;
using Cabinet.Security;
using MyApp.Models;

namespace Cabinet.Generated;

public static class CabinetStoreExtensions
{
    public static IOfflineStore CreateCabinetStore(
        string dataDirectory,
        byte[] masterKey,
        JsonSerializerContext jsonContext)
    {
        var encryptionProvider = new AesGcmEncryptionProvider(masterKey);
        var indexProvider = new PersistentIndexProvider(dataDirectory, encryptionProvider);
        return new FileOfflineStore(
            dataDirectory,
            encryptionProvider,
            jsonContext.Options,
            indexProvider);
    }

    public static RecordSet<LessonRecord> CreateLessonRecordRecordSet(this IOfflineStore store)
        => new(store, LessonRecordExtensions.CreateRecordSetOptions());
}
```

## ID Property Detection

The generator looks for an ID property in this order:

1. Property named `Id` (any type)
2. Property named `{TypeName}Id` (e.g., `LessonRecordId` for `LessonRecord`)

The ID property can be any type - the generator automatically calls `.ToString()!` to convert it to the string required by `RecordSetOptions<T>.IdSelector`.

## Accessibility Modifiers

Generated extension classes **match the accessibility** of your record classes:

- `public record` → generates `public static class {TypeName}Extensions`
- `internal record` → generates `internal static class {TypeName}Extensions`

The shared `CabinetStoreExtensions` class uses the **most restrictive accessibility** from all your records:

- If **any** record is `internal` → `CabinetStoreExtensions` is `internal`
- If **all** records are `public` → `CabinetStoreExtensions` is `public`

This ensures the `CreateCabinetStore` method can accept your `JsonSerializerContext` without accessibility conflicts.

**Example:** If you have both public and internal records, the generated code will be:

```csharp
public static class LessonRecordExtensions { ... }      // matches public record
internal static class InternalNoteExtensions { ... }    // matches internal record

internal static class CabinetStoreExtensions            // internal (most restrictive)
{
    internal static IOfflineStore CreateCabinetStore(
        string dataDirectory,
        byte[] masterKey,
        JsonSerializerContext jsonContext)  // can accept internal context
}
```

## AOT Compatibility

This approach is fully AOT-compatible because:

1. System.Text.Json's source generator processes your manually created `JsonSerializerContext`
2. No reflection is used at runtime
3. All JSON serialisation is resolved at compile time
4. The generated extensions use compile-time type information

## Why Manual JsonSerializerContext?

Source generators run during compilation but cannot reliably coordinate with each other. If our generator tried to create the `JsonSerializerContext`, System.Text.Json's generator wouldn't see it in time to implement the abstract members. By having you create it manually in your own code, System.Text.Json's generator can process it correctly.

## Integration with .NET MAUI

Example MauiProgram.cs configuration:

```csharp
using Microsoft.Extensions.Logging;
using Cabinet;
using Cabinet.Abstractions;
using Cabinet.Generated;
using System.Security.Cryptography;

public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        
        // Configure offline data store
        builder.Services.AddSingleton<IOfflineStore>(sp =>
        {
            // Get or create master key from secure storage
            var keyString = SecureStorage.GetAsync("CabinetMasterKey").GetAwaiter().GetResult();
            byte[] masterKey;
            
            if (keyString == null)
            {
                var newKey = new byte[32];
                RandomNumberGenerator.Fill(newKey);
                keyString = Convert.ToBase64String(newKey);
                SecureStorage.SetAsync("CabinetMasterKey", keyString).GetAwaiter().GetResult();
                masterKey = newKey;
            }
            else
            {
                masterKey = Convert.FromBase64String(keyString);
            }
            
            var rootPath = Path.Combine(FileSystem.AppDataDirectory, "Cabinet");
            
            // Use source-generated store creation
            return CabinetStoreExtensions.CreateCabinetStore(
                rootPath,
                masterKey,
                CabinetJsonContext.Default);
        });
        
        return builder.Build();
    }
}
```

## Troubleshooting

### "CS0053: Inconsistent accessibility"

Your `JsonSerializerContext` and records have mismatched accessibility. **Solution:**

Make sure all `[AotRecord]` classes and your `JsonSerializerContext` have the same accessibility:

```csharp
// ❌ Won't work - public context, internal record
public partial class CabinetJsonContext : JsonSerializerContext { }
[AotRecord]
internal record MyRecord { ... }

// ✓ Option 1: All public
public partial class CabinetJsonContext : JsonSerializerContext { }
[AotRecord]
public record MyRecord { ... }

// ✓ Option 2: All internal
internal partial class CabinetJsonContext : JsonSerializerContext { }
[AotRecord]
internal record MyRecord { ... }
```

**Why:** C# requires that all types exposed through public members must also be public. If your `JsonSerializerContext` is public, all serialized types must be public. If you need internal types, make your context internal too.

### "CS0534: does not implement inherited abstract member"

This means System.Text.Json's generator didn't process your `JsonSerializerContext`. Make sure:

1. The context is in your own code file (not generated)
2. It has the `partial` keyword
3. It has `[JsonSerializable]` attributes for all your types
4. You've rebuilt the project from scratch

### "Cannot convert Guid to string"

This should be automatically handled by the generator (it adds `.ToString()!`). If you see this error, the generator may not be running. Check:

1. The source generator is referenced in your `.csproj` with `OutputItemType="Analyzer"`
2. You've marked your record with `[AotRecord]`
3. You've rebuilt the project

### Generated code not appearing

Source generator output is only visible during build. To see generated files:

1. Build the project
2. Check `obj/Debug/{target}/generated/Cabinet.SourceGenerators/` folder
3. In Visual Studio, expand Dependencies → Analyzers → Cabinet.SourceGenerators
